---
title: Network
date: 2023-05-25 17:34:01
categories: Wiki
tags: [Network, Protocol]
comment: true
---

<!-- more -->

## 总体脉络

### 一、物理层

许多电脑想相互通讯，需要建立连接

- 当只有两台电脑时，只需要一根**网线**，即可以通信（*IO、中断、缓冲区、操作系统*）
- 两个、三个、四个……随着电脑数量增多，难以使任意两个都连接起来，否则网线密密麻麻混乱不堪
- 使用一个中间设备，将所有电脑都与此设备相连，中间的转发全由这个设备完成，与之前本质上一样，只是网口与网线的数量减少了，不再那么混乱；设备名为**集线器**，仅仅将电信号**转发到所有出口（广播）**，没有做任何处理，因此它属于**物理层**
- 转发到了所有出口，每一个连接到集线器的设备都有一个**全局唯一**的名字作为标识，即 **MAC 地址**，此时发送数据只需要在数据包的头部拼接上 MAC 地址即可让接受者判断是否为发给自己的数据包

|     MAC 地址      | 端口 |
| :---------------: | :--: |
| aa-aa-aa-aa-aa-aa |  1   |
| bb-bb-bb-bb-bb-bb |  2   |
| cc-cc-cc-cc-cc-cc |  3   |
| dd-dd-dd-dd-dd-dd |  4   |

虽然这样布局干净很多，但是本来只需要发送给一个电脑的数据，现在要发给连接到集线器的所有电脑，这样既不安全又不节省网络资源

### 二、数据链路层

如果把集线器变得更加智能，只发送给目标 MAC 地址指向的那台电脑就好了

- 使用交换机维护一张 **MAC 地址表**，记录着每个 MAC 地址的设备所在的**端口**，数据到达交换机会通过自动发送给其 MAC 地址所**映射**的端口上，这样的传输方式称为**以太网**
- 通过发送和接受数据，交换机读取所有设备的 MAC 地址与端口并建立 MAC 地址表

交换机 A：

|     MAC 地址      | 端口 |
| :---------------: | :--: |
| aa-aa-aa-aa-aa-aa |  1   |
| bb-bb-bb-bb-bb-bb |  2   |
| cc-cc-cc-cc-cc-cc |  3   |
| dd-dd-dd-dd-dd-dd |  4   |
| ee-ee-ee-ee-ee-ee |  5   |
| ff-ff-ff-ff-ff-ff |  5   |
| gg-gg-gg-gg-gg-gg |  5   |
| hh-hh-hh-hh-hh-hh |  5   |

 交换机 B：

|     MAC 地址      | 端口 |
| :---------------: | :--: |
| aa-aa-aa-aa-aa-aa |  1   |
| bb-bb-bb-bb-bb-bb |  1   |
| cc-cc-cc-cc-cc-cc |  1   |
| dd-dd-dd-dd-dd-dd |  1   |
| ee-ee-ee-ee-ee-ee |  2   |
| ff-ff-ff-ff-ff-ff |  3   |
| gg-gg-gg-gg-gg-gg |  4   |
| hh-hh-hh-hh-hh-hh |  5   |

- 机器数量越来越多，只需要将更多的交换机相连，每个交换机会有个别端口映射为别的交换机

此时只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了

但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万

### 三、网络层

交换机已经无法记录如此庞大的映射关系了

问题在于交换机中映射到其他交换机的端口会有与这些端口数相同的 MAC 地址数，*这会使 MAC 地址表无比庞大*

- 将很每一个交换机都接入一个**新的设备**，这个设备跟电脑一样拥有自己独立的 MAC 地址，同时还能把数据包做一次**转发**，我们称之为**路由器**

> 路由器：一台独立的拥有 MAC 地址的设备，并且可以把数据包做一次转发

- 路由器的每一个端口都有独立的 MAC 地址
- 此时如果有两个电脑需要数据传输，如果同处于一个交换机下，则不需要通过路由器，如何判断是否需要通过路由器
- MAC 地址是**出厂分配**的，全球唯一，因此引入一个新的地址，每台机器分配一个 32 位（二进制）的编号，即 **IP 地址**；此时每台电脑既有自己的 MAC 地址又有自己的 IP 地址；IP 地址在**软件层面**上，可以随时修改，MAC 地址在硬件层面，不能修改
- 此时在两台设备之间传输的信息就包含了两个头部，数据链路层头部和网络层头部
- 两个 IP 处于同一个**子网**就直接通过交换机发送出去，不在同一个子网就交给路由器处理，`192.168.0. xxx` 开头一样的属于同一个子网；计算如何判断？答案是通过**子网掩码**：计算机通过将 IP 地址和子网掩码进行***与运算***

> 如某机器的子网掩码为 255.255.255.0，四台电脑的 IP 地址：
> A 电脑：192.168.0.1 & 225.225.225.0 = 192.168.0.0
> B 电脑：192.168.0.2 & 225.225.225.0 = 192.168.0.0
> C 电脑：192.168.1.1 & 225.225.225.0 = 192.168.1.0
> D 电脑：192.168.1.2 & 225.225.225.0 = 192.168.1.0
> 计算的结果相等，就属于同一个子网
>**子网掩码**其实是表示 IP 地址前多少位表示子网的网段

- 当 A 想与 C 通信时，将 A 和 C 的 IP 地址分别与 A 的子网掩码进行 `&` 运算，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发送给路由器

但是 A 如何知道哪一个是路由器呢？

- 对于 A 来说，它只能把包发送到同处于子网下的某一个 IP 上，所以只需要在 A 电脑内配置一个**默认网关**，也即路由器的 IP 地址
路由器如何知道 C 在哪里？
- 路由器收到包含 IP 地址的数据包，需要判断从哪个端口发送出去，由于子网掩码其实是表示 IP 地址前多少位表示子网的网段，因此可以把 IP 地址与子网掩码合并表示，如 `192.168.0.0（255.255.255.0）` 可以表示为 `192.168.0.0/24`（24 表示子网掩码占 24 个字节），路由器通过**路由表**判断将一个子网下的都转发到对应的端口
发送数据包的数据链路层需要知道 MAC 地址，但是只知道 IP 地址怎么办？
- 答案是 arp 协议；每个电脑都有一张 arp 缓存表，记录着 IP 地址与 MAC 地址的对应关系
- 一开始 arp 缓存表是**空的**，每台电脑都会**广播** arp 请求，收到的电脑会**响应**也即返回自己的 MAC 地址，此时电脑收到返回会**更新**自己的 arp 表

综上，每台电脑都会有如下配置：

|  IP 地址： | 192.168.0.1       |
| ---------: | :---------------- |
| MAC 地址： | AA-AA-AA-AA-AA-AA |
| 子网掩码： | 255.255.255.0     |
| 默认网关： | 192.168.0.254     |

一共涉及三张表：

1. 交换机中有 **MAC 地址**表用于映射 MAC 地址和它的端口
2. 路由器中有**路由表**用于映射 IP 地址与它的端口
3. 电脑和路由器中都有 **arp 缓存表**用于缓存 IP 和 MAC 地址的映射关系

三张表的建立：

1. MAC 地址是通过以太网内各节点之间不断通过交换机通讯而完善的
2. 路由表是各种路由算法+人工配制完善的
3. arp 缓存是不断通过 arp 协议的请求逐步完善的

### 分视角分析

### 电脑视角

- 首先要知道自己的 IP 和对方的 IP
- 通过子网掩码判断两者是否在同一个子网
- 同一个子网就直接通过 arp 协议获取对方的 MAC 地址发送过去
- 不在同一个子网则通过 arp 协议获取默认网关的 MAC 地址发送过去

### 交换机视角

- 收到的数据包必须有目标的 MAC 地址
- 通过 MAC 地址查询映射关系
- 查到就按照映射关系从指定端口发送出去
- 查不到就所有端口都发送

路由器视角

- 收到的数据包必须包含目标的 IP 地址
- 通过路由表查询映射关系
- 查到了就按照映射关系从制定端口发送出去
- 查不到则返回一个路由不可达的数据包

> 网络层（IP 协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的

### 四、传输层

只需要获取对方的 IP 地址，数据包就可以在任意两台的电脑之间进行传输了，但是当一台电脑接收到一个数据包时，具体应该交给哪一个**程序（进程）** 呢？

为了把通信的进程区分开来，就给每一个进程分配一个数字编号，也即端口号；然后在传输的数据包上要加上传输层的头部，即**源端口号**与**目标端口号**
